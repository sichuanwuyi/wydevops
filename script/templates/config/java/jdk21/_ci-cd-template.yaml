#本文件为本脚本项目使用的全功能配置文件。
#不同语言项目使用这个统一的全功能配置文件。
#不同语言项目可能存在不同的参数默认值，请在对应的语言子目录下的_ci-cd-config.yaml文件中配置。
globalParams:
  #服务英文名称，wydevops会自动从yaml类型的配置文件中读取版本信息覆盖serviceName参数。
  #详细配置见配置文件：./param-mapping/params-mapping-in-yaml-file.config
  serviceName: _SERVICE-NAME_
  #服务中文名称
  serviceNameZh: ${serviceName}
  #服务别名，默认等于serviceName，主要用于向外发送的通知内容中。
  serviceCode: ${serviceName}
  #对本服务的一个中文描述说明文本，会写入Chart镜像。
  description: "java服务: ${serviceName}"
  #对本服务的一个英文描述说明文本，会写入Chart镜像。
  descriptionEn: "java service:${serviceName}"

  businessImage: ${serviceName}-business
  #wydevops会自动从yaml类型的配置文件中读取版本信息覆盖businessVersion参数。
  #详细配置见配置文件：./param-mapping/params-mapping-in-yaml-file.config
  businessVersion: 1.0.0
  #业务版本号作为部分名称的后缀时的值, 例如deployment[].name等，用于区分不同版本的资源。
  #脚本会自动随businessVersion值变更而自动更新，主要是用于适配istio的灰度发布功能。
  versionSuffix: 1-0-0
  baseImage: ${serviceName}-base
  baseVersion: ${businessVersion}
  #是否能回滚到上一个版本：如果修改了数据库表结构或字段属性，需要设置为true。
  rollback: true

  #服务所属应用的中文名称。逻辑上，一个应用下可以包含多个业务板块，一个业务板块下可以包含多个服务。
  systemName: ${serviceName}
  #服务所属应用的英文名称。
  systemNameEn: ${serviceName}
  #应用版本。
  systemVersion: ${businessVersion}
  #应用中文描述。
  systemDescr: 系统功能描述
  #应用英文描述。
  systemDescrEn: System functional description
  #服务所属的业务板块名称。逻辑上，一个应用下可以包含多个业务板块，一个业务板块下可以包含多个服务。
  subSystemName: ${serviceName}
  #服务所属的业务板块的英文名称。
  subSystemNameEn: ${serviceName}
  #子应用版本。
  subSystemVersion: ${businessVersion}
  #子应用/模块中文描述。
  subSystemDescr: 子系统或模块功能描述
  #子应用/模块英文描述。
  subSystemDescrEn: Subsystem functional description
  #运行时Runtime的版本
  runtimeVersion:

  #是否使能离线构建，为true则会使用offline子目录下的Dockerfile文件。
  enableOfflineBuild: false

  #Dockerfile文件中From语言中定义的基础镜像。
  #支持多个基础镜像，相互之间使用英文逗号隔开。
  #注意：注意多个基础镜像间的顺序应与在Dockerfile文件中出现的顺序保持一致。
  baseFromImage: _BASE-FROM-IMAGE_
  #需要拷贝到docker构建目录中的目录，多个目录间使用英文逗号隔开。
  copyDirsIntoDocker:
  #需要拷贝到docker构建目录中的文件，多个文件间使用英文逗号隔开。
  copyFilesIntoDocker:

  buildType: _BUILD-TYPE_
  appDirInContainer: /usr/local/app/${serviceName}
  #默认值为"/app",可自定义。
  #当构建类型为single时，脚本会自动在baseWorkDir值的后面添加"-single"后缀。
  #其他构建类型时，脚本会自动在baseWorkDir值的后面添加"-double"后缀。
  baseWorkDir: /app
  workDirInContainer: ${baseWorkDir}/${serviceName}
  archTypes: linux/arm64,linux/amd64

  #需要生成的离线安装报的架构类型，多个架构间使用英文逗号隔离。
  offlineArchTypes: _OFFLINE-ARCH-TYPES_
  useTemplate: _USE-TEMPLATE_
  #有效的构建阶段列表，逗号分隔。为空则表示所有阶段都有效。
  validBuildStages:
  #服务在K8S集群中指定部署的节点选择器
  nodeSelector:
  #服务驱逐优先级
  priorityClassName:

  #服务主端口，也是k8s服务探活和就绪的检测端口，默认是containerPorts参数中第一个端口。
  mainPort: _MAIN-PORT_
  #申明docker容器需要开放的端口列表，端口间使用逗号隔开。
  containerPorts: ${mainPort}
  #ClusterIP类型的Service资源开放的服务端口列表，端口间使用逗号隔开。
  servicePorts: ${mainPort}
  #NodePort类型的Service资源绑定的容器端口列表，端口间使用逗号隔开。
  #默认范围：30000-32767
  nodePorts:

  #服务类型，默认是Deployment。
  serviceKind: Deployment
  #是否启用无头服务，默认是false。
  isHeadlessService: false

  #应用设置的路由前缀参数。
  #当gatewayPath="/"或空时，表示不启用重写机制。
  gatewayPath: /${serviceName}
  #应用设置的路由Host名称，*表示任意Host。
  gatewayHost: "*"
  #istio全局网关名称
  istioGlobalGatewayName: ${serviceName}-gw
  #todo enableRewrite参数的值会自动根据gatewayPath的值更新。
  #是否启用网关路由重写机制，默认为true, 会根据gatewayPath的值自动更新设置：
  #当gatewayPath值为空或"/"时，会自动设置为false。
  enableRewrite: "true"
  #todo apisixRouteRegexUri参数的值会自动根据gatewayPath的值更新。
  apisixRouteRegexUri: "[ \"^${gatewayPath}(?:/|$)(.*)\", \"/$1\" ]"
  #todo apisixIngressTargetRegex参数的值会自动根据gatewayPath的值更新。
  apisixIngressTargetRegex: ^${gatewayPath}(?:/|$)(.*)

  #使用istio时VirtualService资源绑定的Host名称，*表示任意Host。
  istioVirtualServiceHost: "*"
  minProtocolVersion: TLSV1_2
  maxProtocolVersion: TLSV1_3
  #启用指定的DestinationRule资源名称。
  istioSubset: ${serviceName}-subset
  #使用apisixRoute时，是否为当前服务启用网关的websocket功能
  websocket: false
  #使用ingress-nginx时，启用HTTPS协议的域名列表：
  ingressTlsHosts:
  #使用ingress-nginx时，启用HTTPS时需要的secret名称。
  ingressSecretName:

  #ingressApiVersion默认配置为空，非空时优先采用之。
  #如果配置了targetApiServer参数，脚本会到该服务器中查询当前资源类型的版本。
  #ingressApiVersion非空时优先采用之，反之则使用查询到的版本；如果查询失败采用默认值：networking.k8s.io/v1
  ingressApiVersion:
  #apisixApiVersion默认配置为空，非空时优先采用之。
  #如果配置了targetApiServer参数，脚本会到该服务器中查询当前资源类型的版本。
  #apisixApiVersion非空时优先采用之，反之则使用查询到的版本；如果查询失败采用默认值：apisix.apache.org/v2
  apisixApiVersion:
  #istioApiVersion默认配置为空，非空时优先采用之。
  #如果配置了targetApiServer参数，脚本会到该服务器中查询当前资源类型的版本。
  #istioApiVersion非空时优先采用之，反之则使用查询到的版本；如果查询失败采用默认值：networking.istio.io/v1
  istioApiVersion:

  #定义K8S集群内部拉取docker镜像时使用的secret资源的名称，默认设置为空
  imagePullSecret:

  #是否启用K8S服务存活探针
  livenessProbeEnable: true
  livenessUri: /health
  #是否启用K8S服务就绪探针
  readinessProbeEnable: true
  readinessUri: /health
  #探活和就绪使用的HTTP还是HTTPS
  httpGetScheme: HTTP

  #K8S服务CPU和内存资源配置相关参数
  cpuLimits: 1000m
  memoryLimits: 1Gi
  cpuRequests: 1000m
  memoryRequests: 1Gi

  #docker容器内的时区配置
  timeZone: Etc/UTC
  #springboot启动时的推内存参数
  jvmOpts: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=80.0 -XX:InitialRAMPercentage=20.0 -XX:MaxMetaspaceSize=256m -XX:MaxDirectMemorySize=256m"
  #JavaOpts参数
  javaOpts: "--add-opens=java.base/sun.reflect.annotation=ALL-UNNAMED --add-opens=java.base/jdk.internal.access=ALL-UNNAMED --add-opens=java.base/jdk.internal.misc=ALL-UNNAMED --add-opens=java.base/sun.nio.ch=ALL-UNNAMED --add-opens=java.base/sun.util.calendar=ALL-UNNAMED --add-opens=java.management/com.sun.jmx.mbeanserver=ALL-UNNAMED --add-opens=jdk.internal.jvmstat/sun.jvmstat.monitor=ALL-UNNAMED --add-opens=java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens=jdk.management/com.sun.management.internal=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.nio=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.base/java.util.concurrent.locks=ALL-UNNAMED --add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.lang.invoke=ALL-UNNAMED --add-opens=java.base/java.math=ALL-UNNAMED --add-opens=java.sql/java.sql=ALL-UNNAMED --add-opens=java.base/java.lang.reflect=ALL-UNNAMED --add-opens=java.base/java.time=ALL-UNNAMED --add-opens=java.base/java.text=ALL-UNNAMED --add-opens=java.management/sun.management=ALL-UNNAMED --add-opens java.desktop/java.awt.font=ALL-UNNAMED -Dspring.config.location=_WORK-DIR-IN-CONTAINER_/wydevops-config/"

  #需要放到项目默认ConfigMap中的文本文件的相对路径列表，文件间使用英文逗号分隔
  configMapFiles:
  #需要打包到离线安装包中镜像名称，格式：{镜像名称}:{镜像版本},...
  packageImages0: ${baseImage}:${baseVersion},${businessImage}:${businessVersion}

  #chart镜像的名称, 默认与服务的名称相同
  chartName: ${serviceName}
  #chart镜像的版本, 默认与服务的版本相同
  chartVersion: ${businessVersion}
  #chart镜像中应用的版本，默认与服务的版本相同
  appVersion: ${businessVersion}

  #部署类型：k8s(默认值)、docker(支撑docker-compose方式)
  deployType: k8s
  #当前部署环境名称：dev、test，可以自定义。
  activeProfile: dev
  #K8S集群的ApiServer服务器的地址信息（必须配置）
  #格式：{服务器IP地址}|{SSH端口号}|{SSH连接账号}|{SSH连接密码}
  targetApiServer: 172.18.181.116|22|wuyi|Wpl118124
  #部署的命名空间
  targetNamespace: default
  #K8s集群内部拉取镜像的仓库信息
  targetDockerRepo:
  #参数不为空时即表示需要挂载PVC，参数值即为PVC资源名称。
  #挂载路径默认为${serviceName}-workdir
  persistentVolumeClaimName:
  #istio VirtualService资源绑定的网关名称
  istioVirtualServiceGatewayName: ${targetNamespace}/${istioGlobalGatewayName}

#------以下配置为高级配置，在未充分理解的情况下不要轻易改动------#

#项目编译阶段的配置参数
#（项目如可本地构建异构项目（如Java、Go等），直接忽略这个配置节）
build:
  #是否使能离线构建，为true则会使用offline子目录下的Dockerfile文件。
  enableOfflineBuild: ${enableOfflineBuild}
  #目标架构linux/arm64
  linux-arm64:
    #项目编译节点的IP地址
    nodeIP: 192.168.31.160
    #项目编译节点SSH连接账号
    sshAccount: root
    #项目编译节点SSH连接密码
    sshPassword: 123456
    #项目编译使用的镜像名称和版本
    buildImage: java-build-image-linux-arm64:1.0.0
  #目标架构linux/amd64
  linux-amd64:
    #项目编译节点的IP地址
    nodeIP: 192.168.31.161
    #项目编译节点SSH连接账号
    sshAccount: root
    #项目编译节点SSH连接密码
    sshPassword: 123456
    #项目编译使用的镜像名称和版本
    buildImage: java-build-image-linux-amd64:1.0.0

#docker构建阶段的配置参数
docker:
  #构建类型(全部小写)：
  # single：单镜像模式：构建单一的应用镜像
  # double：双镜像模式：构建应用基础镜像和应用业务镜像
  # base：仅构建“应用基础镜像”
  # business：仅构建“应用业务镜像”
  # thirdParty: 打包第三方镜像：拉取第三方镜像，缓存到本地镜像缓存目录中，然后推送到私库中，最后导出到gDockerBuildOutDir目录中。
  # customize: 自定义模式，指定docker构建目录后由本脚本自动完成构建。
  buildType: ${buildType}
  #执行docker build命令时是否添加--no-cache参数。
  enableNoCache: true
  #是否强制使用Docker模板文件。
  useTemplate: ${useTemplate}
  #projectType参数决定了生成时使用的默认Dockerfile模板。
  #有效值(全部为小写)：java、python、c、c++、vue、nextjs等
  projectType: java
  #容器中应用工作路径，
  workDir: ${workDirInContainer}
  #docker容器中应用存储路径，注意要与挂载路径保持一致。
  appDir: ${appDirInContainer}
  #需要拷贝到Docker镜像中的子目录列表，多个子目录间使用逗号间隔，
  #如果不是绝对路径，则父目录为主模块目录。
  copyDirs: ${copyDirsIntoDocker}
  #需要拷贝到Docker镜像中的文件列表，多个文件间使用逗号间隔，
  #如果不是绝对路径，则父目录为主模块目录。
  #copyFiles中文件名称支持带*匹配符
  copyFiles: ${copyFilesIntoDocker}
  #目标架构类型,多项时表示需要构建多个镜像。
  archTypes: ${archTypes}
  #生成的Docker镜像对外暴露的端口列表
  exposePorts: ${containerPorts}
  #docker容器内的时区配置
  timeZone: ${timeZone}
  #JVMOpts参数
  jvmOpts: ${jvmOpts}
  #JavaOpts参数
  javaOpts: ${javaOpts}
  business:
    name: ${businessImage}
    #业务镜像的版本
    version: ${businessVersion}
    #使用的第三方的基础镜像. 多个镜像间使用英文逗号分隔，
    #依次对应Dockerfile文件中存在的 _FROM-IMAGE0_,_FROM-IMAGE1_, ...
    fromImage: busybox:latest
  base:
    name: ${baseImage}
    #输出的业务基础镜像的版本
    version: ${baseVersion}
    #业务基础镜像使用的第三方基础镜像，多个镜像间使用英文逗号分隔，
    #依次对应Dockerfile文件中存在的 _FROM-IMAGE0_,_FROM-IMAGE1_, ...
    fromImage: ${baseFromImage}
  #要打包的第三方镜像列表
  thirdParties:
    - name: third-party
      #第三方镜像的名称和版本，不能为空。
      #目标镜像的架构由docker.archTypes参数决定。
      images:
      #第三方镜像导出文件所在的目录，如果为空，则直接从私库或公网拉取目标镜像。
      #目录中的导出文件格式为：{镜像名称}-{架构类型,例如：linux/amd64}.tar；其中\”:\“和\”/\“都转换为\”-\“。
      #举例：bitnami/prometheus:2.51.2镜像的导出文件名称为bitnami-prometheus-1.0.0-linux-amd64.tar
      location:
  customizes:
      #自定义Docker构建目录中生成的镜像名称和版本，不能空。
    - name: ${serviceName}-linux-amd64:${businessVersion}
      #目标架构类型, 当buildType=customize时，会忽略docker.archTypes参数。
      #该值必须与下面的dockerfile参数指定的文件中的From语句中的--platform参数保持一致，否则会报错。
      archType: linux/amd64
      #指定自定义Docker构建目录和Dockerfile文件。
      dockerfile: ./docker/amd64/Dockerfile
    #自定义Docker构建目录中生成的镜像名称和版本，不能空。
    - name: ${serviceName}-linux-arm64:${businessVersion}
      #目标架构类型, 当buildType=customize时，会忽略docker.archTypes参数。
      archType: linux/arm64
      #指定自定义Docker构建目录和Dockerfile文件。
      dockerfile: ./docker/arm64/Dockerfile

#chart过程需要完成helm打包的chart镜像配置项列表。
#每一项对应一个chart镜像打包配置；即同时可支持多个chart镜像的打包。
#绝大多数项目只会存在一个chart镜像打包配置项。
chart:
    #列表项的唯一名称
  - name: ${chartName}
    version: ${chartVersion}
    appVersion: ${appVersion}
    #如果是自定义helm打包, 以下参数需要设置成自定义helm打包目录。
    #对于自定义helm打包方式,需要人工保证打包目录中文件内容的正确性。
    #脚本框架只负责helm package和 helm push等流程操作。
    customizedHelmDir:
    #Chart.yaml文件中的description内容。
    description: ${description}
    descriptionEn: ${descriptionEn}
    #设置引用的外部服务的chart镜像(*.tgz)。可以设置多个，相互间使用英文逗号分隔。
    #如果配置值带有路径则直接使用，否则会从本地系统或配置的chart镜像仓库获取目标镜像。
    #这个参数实现了一个Chart镜像包含多个服务的发布方式。
    #默认情况下应设置为空。
    refExternalCharts:
    #以下deployments和params配置节参数对于自定义helm打包方式无意义。
    #配置chart镜像中需要发布的Deployment/DaemonSet/StatefulSet服务。
    #每一个配置项都会对应生成一套deployment.yaml、route.yaml、service.yaml、configMap.yaml
    # serviceAccount.yaml、hpa.yaml等配置文件
    deployments:
      - name: ${serviceName}-${versionSuffix}
        #指明引用的外部Chart镜像名称。如果是带路径的名称，则直接使用，否则会尝试从Chart仓库拉取镜像。
        #这个参数主要用来支持单pod多服务的Chart打包方式。wydevops会将外部chart镜像中deployment[0]的
        #initialContainers和containers合并到当前chart中。
        #支持设置多个chart镜像，相互间使用英文逗号隔开。
        #默认情况下应设置为空。
        refExternalContainers:
        #配置chart镜像中需要发布的服务的类型：Deployment、DaemonSet、StatefulSet。
        kind: ${serviceKind}
        replicaCount: 1
        priorityClassName: ${priorityClassName}
        imagePullSecrets:
          - name: ${imagePullSecret}
        serviceAccount:
          create: true
          annotations: {}
          name: ""
        podSecurityContext: {}
        securityContext: {}
        autoscaling:
          enabled: false
          minReplicas: 1
          maxReplicas: 100
          targetCPUUtilizationPercentage: 80
          # targetMemoryUtilizationPercentage: 80
        nodeSelector: ${nodeSelector}
        serviceSelector: ${serviceName}
        tolerations: []
        affinity: {}
        podLabels:
          version: ${businessVersion}
        podAnnotations:
          wydevops/service-name: ${serviceNameZh}
          wydevops/service-name-en: ${serviceName}
          wydevops/service-descr: ${description}
          wydevops/service-descr-en: ${descriptionEn}
          wydevops/system-name: ${systemName}
          wydevops/system-name-en: ${systemNameEn}
          wydevops/system-version: ${systemVersion}
          wydevops/system-descr: ${systemDescr}
          wydevops/system-descr-en: ${systemDescrEn}
          wydevops/sub-system-name: ${subSystemName}
          wydevops/sub-system-name-en: ${subSystemNameEn}
          wydevops/sub-system-version: ${subSystemVersion}
          wydevops/sub-system-descr: ${subSystemDescr}
          wydevops/sub-system-descr-en: ${subSystemDescrEn}
        #参数不为空时即表示需要挂载PVC，参数值即为PVC资源名称。
        #挂载路径默认为${serviceName}-workdir
        persistentVolumeClaimName: ${persistentVolumeClaimName}
        volumes:
          - name: ${serviceName}-workdir
            emptyDir: {}
          - name: ${serviceName}-config
            configMap:
              defaultMode: 493
              name: ${serviceName}-${versionSuffix}-configmap
              optional: false
          - name: public-configs
            configMap:
              defaultMode: 493
              name: public-configs-configmap
              optional: true
          #挂载公共配置信息
          #- name: public-params
          #  configMap:
          #    name: public-configs
          #    optional: true
          #挂载pvc的例子
          #- name: public-storage
          #  persistentVolumeClaim:
          #    claimName: public-storage-pvc
        #initContainers的第一个容器，其名称默认应该等于服务名称。
        initContainers:
          - name: ${serviceName}-${versionSuffix}-business
            repository: ${businessImage}
            pullPolicy: Always
            tag: ${businessVersion}
            args: []
            command:
              - "sh"
              - "-c"
              - "mkdir -p ${workDirInContainer} && cp -arf ${appDirInContainer}/. ${workDirInContainer}"
            volumeMounts:
              - name: ${serviceName}-workdir
                mountPath: ${workDirInContainer}
        #如果没有initContainers配置（即buildType=single），
        #则containers的第一个容器其名称默认应该等于服务名称。
        containers:
          - name: ${serviceName}-${versionSuffix}-base
            repository: ${baseImage}
            pullPolicy: Always
            tag: ${baseVersion}
            #容器关联的Service的配置信息，自动生成的，不需要配置，此处申明主要是用来占位
            service:
            ports:
              - name: http
                protocol: TCP
                containerPort: ${containerPorts}
                servicePort: ${servicePorts}
                nodePort: ${nodePorts}
            #定义环境变量
            env:
              - name: NODE_NAME
                valueFrom:
                  fieldRef:
                    fieldPath: spec.nodeName
              - name: NODE_IP
                valueFrom:
                  fieldRef:
                    fieldPath: status.hostIP
            envFrom:
            volumeMounts:
              - name: ${serviceName}-workdir
                mountPath: ${workDirInContainer}
              - name: ${serviceName}-config
                #mountPath参数的前缀必须与docker.workDir参数一致。
                mountPath: ${workDirInContainer}/wydevops-config
              #挂载公共配置信息
              - name: public-configs
                mountPath: /var/public-configs
              #挂载pvc的例子
              #- name: public-storage
              #  mountPath: ${workDirInContainer}/data
            resources:
              limits:
                cpu: ${cpuLimits}
                memory: ${memoryLimits}
              requests:
                cpu: ${cpuRequests}
                memory: ${memoryRequests}
            livenessProbeEnable: ${livenessProbeEnable}
            livenessProbe:
              initialDelaySeconds: 15
              failureThreshold: 10
              periodSeconds: 5
              successThreshold: 1
              timeoutSeconds: 5
              httpGet:
                scheme: ${httpGetScheme}
                port: ${mainPort}
                path: ${livenessUri}
            readinessProbeEnable: ${readinessProbeEnable}
            readinessProbe:
              initialDelaySeconds: 15
              failureThreshold: 10
              periodSeconds: 5
              successThreshold: 1
              timeoutSeconds: 5
              httpGet:
                scheme: ${httpGetScheme}
                port: ${mainPort}
                path: ${readinessUri}
        #定义configmap名称（格式：{服务名称}-{版本后缀}-configmap）及其包含的文件列表
        configMaps:
            #名称必须与volumes中的某个ConfigMap名相同
          - name: ${serviceName}-${versionSuffix}-configmap
            files: ${configMapFiles}

        resourcePlugins:
          - name: ConfigMap
            generatorName: default
            enable: true
            configPath:
          - name: Secret
            generatorName: default
            enable: false
            configPath:
          - name: Deployment
            generatorName: default
            enable: true
            configPath:
          - name: DaemonSet
            generatorName: default
            enable: true
            configPath:
          - name: StatefulSet
            generatorName: default
            enable: true
            configPath:
          - name: Service
            generatorName: default
            enable: true
            configPath:
          - name: Gateway
            generatorName: default
            enable: true
            configPath: istioRoute
          - name: VirtualService
            generatorName: default
            enable: true
            configPath: istioRoute
          - name: DestinationRule
            generatorName: default
            enable: true
            configPath: istioRoute
          - name: ServiceAccount
            generatorName: default
            enable: true
            configPath:
          - name: HorizontalPodAutoscaler
            generatorName: default
            enable: true
            configPath:
          - name: Ingress
            generatorName: default
            enable: false
            configPath: ingressRoute
          - name: ApisixRoute
            generatorName: default
            enable: false
            configPath: apisixRoute

        #Ingress-nginx网关路由配置
        ingressRoute:
          type: Ingress
          apiVersion: ${ingressApiVersion}
          className: nginx
          #annotations下属参数用于路由重写配置
          #其中app-root与use-regex、rewrite-target不能同时配置。
          annotations:
            #以下两个参数使能Websocket功能。
            nginx.ingress.kubernetes.io/websocket-services: "${serviceName}-clusterip"
            #为Websocket适当增加超时时间
            nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
            #下面app-root参数可以给所有请求的URI添加一个路径前缀。
            #nginx.ingress.kubernetes.io/app-root: /app1
            #下面的use-regex和rewrite-target配合可以删除请求的URI中的某个子路径。
            nginx.ingress.kubernetes.io/use-regex: "true"
            #$2表示rules[0].paths[0].path的值中第二个圆括号中的子路径。
            nginx.ingress.kubernetes.io/rewrite-target: /$1
#         tls:
#           - hosts: [ ${ingressTlsHosts} ]
#             secretName: ${ingressSecretName}
          rules:
            - host:
              paths:
                - path: ^${gatewayPath}(?:/|$)(.*)
                  pathType: Prefix
                  serviceName: ${serviceName}-clusterip
                  servicePort: ${mainPort}

        #ingress-apisix网关路由配置
#        ingressRoute:
#          name: ${serviceName}
#          type: Ingress
#          apiVersion: ${ingressApiVersion}
#          className: apisix
#          #annotations下属参数用于路由重写配置
#          #其中app-root与use-regex、rewrite-target不能同时配置。
#          annotations:
#            #使能跨越访问功能
#            k8s.apisix.apache.org/enable-cors: "true"
#            #使能websocket功能
#            k8s.apisix.apache.org/enable-websocket: "${websocket}"
#            #下面的rewrite-target-regex和rewrite-target-regex-template配合可以删除请求的URI中的某个子路径。
#            k8s.apisix.apache.org/rewrite-target-regex: "${apisixIngressTargetRegex}"
#            #$1表示rewrite-target-regex的值中第一个圆括号中的子路径。
#            k8s.apisix.apache.org/rewrite-target-regex-template: "/$1"
#          #         tls:
#          #           - hosts: [ ${ingressTlsHosts} ]
#          #             secretName: ${ingressSecretName}
#          rules:
#            - host:
#              paths:
#                - path: ^${gatewayPath}(?:/|$)(.*)
#                  pathType: Prefix
#                  serviceName: ${serviceName}-clusterip
#                  servicePort: ${mainPort}

        #Apisix网关路由配置
        apisixRoute:
          type: ApisixRoute
          apiVersion: ${apisixApiVersion}
          routes:
            - name: ${serviceName}
              #是否使能Websocket功能
              websocket: ${websocket}
              match:
                hosts: []
                paths: ["^${gatewayPath}(?:/|$)(.*)"]
              plugins:
                #是否开启跨域
                - name: cors
                  enable: true
                #开启路由重写功能
                - name: proxy-rewrite
                  regex_uri: ${apisixRouteRegexUri}
              backends:
                - serviceName: ${serviceName}-clusterip
                  servicePort: ${mainPort}

        istioRoute:
          apiVersion: ${istioApiVersion}
          gateway:
            name: ${istioGlobalGatewayName}
            #完整的istio网关配置，优先于简略配置。
            servers:
            #如下为简略的istio网关配置。与servers配置互斥。
            #https的证书所在的Secret对象名称
            credentialName: ${ingressSecretName}
            #这个端口号是由istio-ingressgateway服务决定。
            portNumber: 80
            # 显式声明HTTP协议
            protocol: HTTP
            hosts:
              - "*"
          virtualService:
            name: ${serviceName}-vs
            hosts:
              - ${istioVirtualServiceHost}
            gateways:
              #默认配置的istio集成亚马逊alb的网关，需要根据实际值进行设置。
              - ${istioVirtualServiceGatewayName}
            # 新增TLS版本限制
            #tls:
            #  minProtocolVersion: ${minProtocolVersion}
            #  maxProtocolVersion: ${maxProtocolVersion}
            http:
              - name: base
                match:
                  - uri:
                      #注意下列prefix值应以“/”结尾，此时rewrite.uri才可以设置为“/”
                      #如果下列prefix值未以“/”结尾，则rewrite.uri应设置为“ ”
                      prefix: "${gatewayPath}/"
                #如果需要重写路由，则打开下面的配置项，并正确设置uri参数。
                rewrite:
                  #如果上述prefix字段不以“/”结尾，则设置为" "表示删除上述prefix参数指定的前缀。
                  #如果不设置则表示不启用路由重写功能
                  uri: "/"
                route:
                  - destination:
                      port:
                        number: ${mainPort}
                      host: ${serviceName}-clusterip.${targetNamespace}
                      #设置默认选中的服务子集。
                      subset: ${versionSuffix}
                    #默认所有流量都导流到${serviceName}-clusterip
                    weight: 100
                #默认启用websocket升级
                websocketUpgrade: true
                #为避免长连接被 Istio 默认超时切断，此值应大于Websocket心跳超时时间。0表示永不不超时。
                timeout: 30s
          destinationRule:
            name: ${serviceName}-dr
            host: ${serviceName}-clusterip
            trafficPolicy:
              #定义全局负载均衡策略, 默认就是ROUND_ROBIN
              #loadBalancer:
              #  simple: ROUND_ROBIN
              connectionPool:
                tcp:
                  maxConnections: 1000  # 最大连接数
                  connectTimeout: 3s # 连接超时
                http:
                  http1MaxPendingRequests: 1024
                  maxRequestsPerConnection: 0  # 0表示不限制，适用于WebSocket
            subsets:
              - name: ${versionSuffix}
                labels:
                  version: ${businessVersion}
                # 在每个subset中单独定义流量策略（如果需要）
                #trafficPolicy:
                #  loadBalancer:
                #    simple: ROUND_ROBIN

    #需要写入values.yaml文件的自定义配置信息。
    params:
      #CPU和内存资源的配置参数
      configurable:
        - name: "资源配置|Resource Configuration"
          catalog: "部署参数|General Parameters"
          catalogIndex: 999
          items:
            - name: "CPU预订核数|CPU Request Cores"
              key: "resources.requests.cpu"
              required: true
              type: "inputNumber"
              value: "${cpuRequests}"
              ranges: "[1,1000,100]"
              units: "毫核:m,核:core|mCore:m,Core:core"
              description: "服务预订的CPU核数，取值范围：1-1000，单位：毫核或核|CPU Request Cores, Range: [1,1000], Unit: mCore or Core"
            - name: "CPU最大可用核数|CPU Maximum Available Cores"
              key: "resources.limits.cpu"
              required: true
              type: "inputNumber"
              value: "${cpuLimits}"
              ranges: "[1,1000,100]"
              units: "毫核:m,核:core|mCore:m,Core:core"
              description: "服务最大可用CPU核数，取值范围：1-1000，单位：毫核或核|CPU Maximum Available Cores, Range: [1,1000], Unit: mCore or Core"
            - name: "内存预订额度|Memory Requested Quota"
              key: "resources.requests.memory"
              required: true
              type: "inputNumber"
              value: "${memoryRequests}"
              ranges: "[1,1000,100]"
              units: "兆字节:Mi,吉字节:Gi|MB:Mi,GB:Gi"
              description: "服务预订的内存额度，取值范围：1-1000，单位：兆字节或吉字节|Memory Requested Quota, Range: [1,1000], Unit: MB or GB"
            - name: "内存最大可用额度|Memory Maximum Available Quota"
              key: "resources.limits.memory"
              required: true
              type: "inputNumber"
              value: "${memoryLimits}"
              ranges: "[1,1000,100]"
              units: "兆字节:Mi,吉字节:Gi|MB:Mi,GB:Gi"
              description: "服务最大可用内存额度，取值范围：1-1000，单位：兆字节或吉字节|Memory Maximum Available Quota, Range: [1,1000], Unit: MB or GB"

package:
  - name: ${chartName}
    #绑定离线打包的chart
    chartName: ${chartName}
    chartVersion: ${chartVersion}
    #离线包中镜像的架构类型，是多项则打出的离线包就是多个。
    #离线包名称：{chartName}-{archType}-{chartVersion}.tar.gz
    archTypes: ${offlineArchTypes}
    #设置离线安装包中需要包含的镜像列表。
    #wydevops会自动从chart镜像中收集需要的docker镜像，并与下列参数的值进行合并去重。
    #可在这个参数中设置好需要额外上传的其他docker镜像。
    images: ${packageImages0}

deploy:
    #列表项的唯一名称
  - name: ${chartName}
    #要部署的离线包名称。
    packageName: ${chartName}
    #发布类型：k8s或docker
    deployType: ${deployType}
    #安装模式：install、upgrade、uninstall
    installMode: install
    #部署的目标环境。
    activeProfile: ${activeProfile}
    #部署时使用的临时目录名称，
    deployTempDirName: deploy
    #部署完毕后是否删除使用的临时文件
    deleteTempDirAfterDeployed: false
    #为Chart镜像values.yaml配置文件params配置节中的参数提供默认值
    #如果部署时deployType=docker，则wydevops会自动更新docker镜像外挂的配置文件中对应参数的值。
    params:
    k8s:
      #开发集群环境
      dev:
        #K8S集群的ApiServer服务器的地址信息（必须配置）
        #格式：{节点IP}|{SSH端口}|{SSH连接账号}|{SSH连接密码}
        #多个集群的ApiServer服务器地址间使用英文逗号隔开。
        apiServer: ${targetApiServer}
        #发布服务的命名空间（必须配置）
        namespace: ${targetNamespace}
        #目标集群使用的docker仓库信息。
        #格式：{仓库类型(nexus或harbor)},{仓库实例名称(nexus)或项目名称(harbor)},{仓库访问地址({IP}:{端口})},{登录账号},{登录密码},
        #{Web管理端口(RestfulAPI接口使用的端口)},{镜像名称是否带仓库实例名前缀(仅对nexus类型仓库有效)}
        dockerRepo: ${targetDockerRepo}
        #部署时指定的网关路由hosts/host参数的值(可不配置),目前只支持设置一个域名
        routeHosts: ${gatewayHost}
      #测试集群环境
      #test:
      #  ...
    docker:
      #发布模式：docker或docker-compose
      mode: docker
      #指定用于生成docker-run.sh文件的生成器脚本，或者直接是docker run命令字符串。
      dockerRunShellGenerator:
      #指定用于生成docker-compose.yaml的生成器脚本，或者直接是docker-compose.yaml文件。
      dockerComposeYamlGenerator:
      #开发集群环境
      dev:
        #设置是否启用代理模式。
        #如果设置enableProxy=ture,则仅向同架构的第一个节点部署服务，由该节点完成向其他节点的部署服务的任务。
        #如果设置enableProxy=false,则会循环向给定的服务器部署服务。
        enableProxy: false
        #docker部署方式时，需要部署的节点信息列表。
        nodeIPs:
          #格式：{节点IP}|{SSH端口}|{SSH连接账号}|{SSH连接密码}
          #第一个节点必须是能免密直连其他节点。
          - ${targetApiServer}
      #测试集群环境
      #test:
      #  ...
